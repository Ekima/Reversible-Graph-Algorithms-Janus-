 /*
  * getlist gets the contents of a single list in the adjacency list.
  *
  * Parameters:
  * int adjacent[]  A list of adjacency list elements
  * int ptrs[]      A list of pointers to the start of each individual list
  * int i           The list that should get extracted (numbered)
  * int res[]       A list to store the returned elements in
  * 
  * Returns:
  * A copy of a the items in a list in the adjacency list.
  */
procedure getlist(int adjacent[], int ptrs[], int lsize, int i, int res[])
    // end contains a pointer to the end of the wanted list
    local int end = 0
    if i = lsize then
        // If we try to get the last list we stop at the end of the element list
        end += size(adjacent)
    else
        // Or else, we stop where the next list starts
        end += ptrs[0][i]
    fi i = lsize
    
    // All elements of the wanted list are loaded into res
    local int r = ptrs[0][i-1]
    from r = ptrs[0][i-1] do
        res[r - ptrs[0][i-1]] += adjacent[r]
        r += 1
    until r = end
    delocal int r = end
    
    // end is delocated
    if i = lsize then
        end -= size(adjacent)
    else
        end -= ptrs[0][i]
    fi i = lsize
    delocal int end = 0

/*
 * enqueue adds an item to a queue.
 * 
 * Parameters:
 * int queue[]      Queue to add item to.
 * int tailpointer  Pointer to the last item in the queue
 * int item         Item to add to the queue.
 * 
 * Returns:
 * A queue with the item added to the tail and an empty item (0).
 *
 * Errors:
 * Item added to the queue is empty (0).
 * Queue is full.
 */
 
procedure enqueue(int queue[], int tailpointer, int item)
    // Error checks (input)
    if item = 0 then
        error("Item added to queue is empty (0).")
    fi item = 0
    if queue[tailpointer] != 0 then
        error("Queue is full. Cannot enqueue item.")
    fi queue[tailpointer] != 0
    
    // Adds the item to the queue spot and empties the item
    local int tmp = item
        queue[tailpointer] += tmp
        item -= tmp
    delocal int tmp = queue[tailpointer]
    
    // Goes to next queue spot
    if tailpointer + 1 != size(queue) then
        tailpointer += 1
    else
        tailpointer -= size(queue) - 1
    fi tailpointer != 0

/*
 * dequeue removes an item to a queue.
 * 
 * Parameters:
 * int queue[]      Queue to add item to.
 * int headpointer  Pointer to the first item in the queue
 * int item         Empty item placeholder.
 * 
 * Returns:
 * A queue with the first item removed and the dequeued item.
 *
 * Errors:
 * Placeholder item not empty (0).
 * Queue is empty.
 */
 
procedure dequeue(int queue[], int headpointer, int item)
    // Error checks (input)
    if item != 0 then
        error("Placeholder not empty (0).")
    fi item != 0
    if queue[headpointer] = 0 then
        error("Queue is empty. Tried to remove item from empty queue.")
    fi queue[headpointer] = 0
    
    // Loads the queue item into the placeholder and empties the queue spot
    local int tmp = queue[headpointer]
        item += tmp
        queue[headpointer] -= tmp
    delocal int tmp = item
    
    // Goes to next queue spot
    if headpointer + 1 != size(queue) then
        headpointer += 1
    else
        headpointer -= size(queue) - 1
    fi headpointer != 0

/*
Breadth-first algorithm
*/

procedure BFS(int Gadjacent[], int Gnodes[], int Gsize, int s,
              int headpointer, int order[])
    // FIFO queue
    local int queue[Gsize] = {0}
    local int tailpointer = headpointer
    // Storage for dequeued node and adjacent nodes, loopcounter
    local int store = 0, int adjstore = 0, int i = 0
    local int adj[Gsize] = {0} // Stores the current adjacent nodes
    
    // We mark the current node as the source node and enqueue it
    Gnodes[1][s-1] -= 1
    store += s  
    call enqueue(queue, tailpointer, store)
    
    from headpointer = 0 do
        if queue[headpointer] != 0 then
            // We dequeue a node and gets its adjacency list
            call dequeue(queue, headpointer, store)
            call getlist(Gadjacent, Gnodes, Gsize, store, adj)
            order[headpointer] += store
            
            // We check the list and enqueue all unvisited nodes
            from i = 0 do
                if adj[i] = 0 then
                    skip
                else
                    if Gnodes[1][adj[i]-1] = 0 then
                        adjstore += adj[i]
                        Gnodes[1][adj[i]-1] += store
                        call enqueue(queue, tailpointer, adjstore)
                    fi Gnodes[1][adj[i]-1] = store
                fi adj[i] = 0
                i += 1
            until i = Gsize
            i -= Gsize
            
            // Remove the content from adj and store
            uncall getlist(Gadjacent, Gnodes, Gsize, store, adj)
            store -= order[headpointer]
        fi queue[headpointer] != 1
    until headpointer = tailpointer
    
    // Delocal local variables
    
    delocal int adj[Gsize] = {0}
    delocal int store = 0, int adjstore = 0, int i = 0
    delocal int tailpointer = headpointer
    delocal int queue[Gsize] = {0}

procedure printpath(int Gnodes[], int v)
    local int u = Gnodes[1][v-1]
    if Gnodes[1][v-1] = 0 then
        printf("No path exists from the source of G to node %d",  v)
    else
        if Gnodes[1][v-1] != -1 then
            call printpath(Gnodes, u)
        fi Gnodes[1][v-1] != -1
        printf("%d",  v)
    fi Gnodes[1][v-1] = 0
    delocal int u = Gnodes[1][v-1]

/*
 * Main procedure. Creates an adjacency list and runs BFS, then printpath on it.
 */
procedure main()
    // Adjacency list, list of adjacent nodes
    int Gadjacent[] = {2, 4, 1, 5, 4, 1, 3, 5, 2, 4, 7, 4}
    int Gsize = 7
    // Adjacency list, node information.
    // Each node has a pointer to their first element
    // Each node stores its parent
    int Gnodes[2][Gsize] = {{0, 2, 4, 5, 8, 10, 11}, {0}}
    int headpointer = 0
    int order[Gsize] = {0}
    
    int s = 1
    int v = 3
    
    call BFS(Gadjacent, Gnodes, Gsize, s, headpointer, order)
    print("A shortest path from source 1 to node 3:")
    call printpath(Gnodes, v)
    v += 2
    print("A shortest path from source 1 to node 5:")
    call printpath(Gnodes, v)
    v += 2
    print("A shortest path from source 1 to node 7:")
    call printpath(Gnodes, v)