 /*
  * getlist gets the contents of a single list in the adjacency list.
  *
  * Parameters:
  * int adjacent[]  A list of adjacency list elements
  * int ptrs[]      A list of pointers to the start of each individual list
  * int i           The list that should get extracted (numbered)
  * int res[]       A list to store the returned elements in
  * 
  * Returns:
  * A copy of a the items in a list in the adjacency list.
  */
procedure getlist(int adjacent[], int ptrs[], int lsize, int i, int res[])
    // end contains a pointer to the end of the wanted list
    local int end = 0
    if i = lsize - 1 then
        // If we try to get the last list we stop at the end of the element list
        end += size(adjacent)
    else
        // Or else, we stop where the next list starts
        end += ptrs[0][i + 1]
    fi i = lsize - 1
    
    // All elements of the wanted list are loaded into res
    local int r = ptrs[0][i]
    from r = ptrs[0][i] do
        res[r - ptrs[0][i]] += adjacent[r]
        r += 1
    until r = end
    delocal int r = end
    
    // end is delocated
    if i = lsize - 1 then
        end -= size(adjacent)
    else
        end -= ptrs[0][i + 1]
    fi i = lsize - 1
    delocal int end = 0

/*
 * enqueue adds an item to a queue.
 * 
 * Parameters:
 * int queue[]      Queue to add item to.
 * int tailpointer  Pointer to the last item in the queue
 * int item         Item to add to the queue.
 * 
 * Returns:
 * A queue with the item added to the tail and an empty item (0).
 *
 * Errors:
 * Item added to the queue is empty (0).
 * Queue is full.
 */
 
procedure enqueue(int queue[], int tailpointer, int item)
    // Error checks (input)
    if item = 0 then
        error("Item added to queue is empty (0).")
    fi item = 0
    if queue[tailpointer] != 0 then
        error("Queue is full. Cannot enqueue item.")
    fi queue[tailpointer] != 0
    
    // Adds the item to the queue spot and empties the item
    local int tmp = item
        queue[tailpointer] += tmp
        item -= tmp
    delocal int tmp = queue[tailpointer]
    
    // Goes to next queue spot
    if tailpointer + 1 != size(queue) then
        tailpointer += 1
    else
        tailpointer -= size(queue) - 1
    fi tailpointer != 0

/*
 * dequeue removes an item to a queue.
 * 
 * Parameters:
 * int queue[]      Queue to add item to.
 * int headpointer  Pointer to the first item in the queue
 * int item         Empty item placeholder.
 * 
 * Returns:
 * A queue with the first item removed and the dequeued item.
 *
 * Errors:
 * Placeholder item not empty (0).
 * Queue is empty.
 */
 
procedure dequeue(int queue[], int headpointer, int item)
    // Error checks (input)
    if item != 0 then
        error("Placeholder not empty (0).")
    fi item != 0
    if queue[headpointer] = 0 then
        error("Queue is empty. Tried to remove item from empty queue.")
    fi queue[headpointer] = 0
    
    // Loads the queue item into the placeholder and empties the queue spot
    local int tmp = queue[headpointer]
        item += tmp
        queue[headpointer] -= tmp
    delocal int tmp = item
    
    // Goes to next queue spot
    if headpointer + 1 != size(queue) then
        headpointer += 1
    else
        headpointer -= size(queue) - 1
    fi headpointer != 0

/*
Breadth-first algorithm
*/

procedure BFS(int Gadjacent[], int Gnodes[], int Gsize, int s)
    // FIFO queue
    local int queue[Gsize] = {0}
    local int headpointer = 0
    local int tailpointer = 0
    // Local storage
    local int store = 0
    local int adjstore = 0
    // Local storage for adjacency lists
    local int adj[Gsize] = {0}
    // Counters
    local int i = 0
    local int n = 1
    
    // We mark the current node as visited and enqueues it
    store += n
    Gnodes[1][store-1] += store
    call enqueue(queue, tailpointer, store)
    
    from headpointer = 0 do
        if queue[headpointer] != 0 then
            // We dequeue a node and gets its adjacency list
            call dequeue(queue, headpointer, store)
            call getlist(Gadjacent, Gnodes, Gsize, store, adj)
            
            // We check the list and enqueue all unvisited nodes
            from i = 0 do
                if adj[i] != 0 && Gnodes[1][adj[i]-1] = 0 then
                    n += 1
                    adjstore += adj[i]
                    Gnodes[1][adj[i]-1] += n
                    call enqueue(queue, tailpointer, adjstore)
                fi Gnodes[1][adj[i]-1] = n
                i += 1
            until i = Gsize
            
            // Remove the content from adj and store
            uncall getlist(Gadjacent, Gnodes, Gsize, store, adj)
            store -= Gnodes[1][store-1]
        fi queue[headpointer] = 0
    until headpointer = tailpointer
    
    // Delocal local variables
    
    delocal int n = Gsize
    delocal int i = 0
    delocal int adj[Gsize] = {0}
    delocal int adjstore = 0
    delocal int store = 0
    delocal int tailpointer = 0
    delocal int headpointer = 0
    delocal int queue[Gsize] = {0}

/*
 * Main procedure. Creates an adjacency list and runs BFS, then printpath on it.
 */
procedure main()
    // Adjacency list, list of adjacent nodes
    int Gadjacent[] = {2, 4, 1, 5, 4, 1, 3, 5, 2, 4}
    // Adjacency list, node information.
    // Each node has a pointer to their first element
    int Gnodes[2][5] = {{0, 2, 4, 5, 8}, {0}}
    int Gsize = 5
    
    int s = 1
    
    call BFS(Gadjacent, Gnodes, Gsize, s)
    //call printpath(Gadjacent, Gnodes, s, v)