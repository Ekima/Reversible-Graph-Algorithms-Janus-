/*
Breadth-first algorithm
*/

procedure BFS(int root[], int v1[], int v2[], int v3[], int v4[], int res0[],
              int res1[], int res2[], int res3[], int res4[], int queue[])
    local int set[] = {1, 0, 0, 0, 0}
    local int queuecount = 1 // Used to keep track of the amount of items in queue
    local int cur = 1 // Used to keep track of the current item in queue
    
    from cur = 1 do
    
        if queue[0] = cur then
            local int i = 0
            from i = 0 do
                if root[i] = 1 && set[i] = 0 then
                    res0[i] += 1
                    set[i] += 1
                    queuecount += 1
                    queue[i] += queuecount
                fi res0[i] = 1
                i += 1
            until i = 5
            delocal int i = 5
            cur += 1
        fi queue[0] = cur - 1
        
        if queue[1] = cur then
            local int i = 0
            from i = 0 do
                if v1[i] = 1 && set[i] = 0 then
                    res1[i] += 1
                    set[i] += 1
                    queuecount += 1
                    queue[i] += queuecount
                fi res1[i] = 1
                i += 1
            until i = 5
            delocal int i = 5
            cur += 1
        fi queue[1] = cur - 1
        
        if queue[2] = cur then
            local int i = 0
            from i = 0 do
                if v2[i] = 1 && set[i] = 0 then
                    res2[i] += 1
                    set[i] += 1
                    queuecount += 1
                    queue[i] += queuecount
                fi res2[i] = 1
                i += 1
            until i = 5
            delocal int i = 5
            cur += 1
        fi queue[2] = cur - 1
        
        if queue[3] = cur then
            local int i = 0
            from i = 0 do
                if v3[i] = 1 && set[i] = 0 then
                    res3[i] += 1
                    set[i] += 1
                    queuecount += 1
                    queue[i] += queuecount
                fi res3[i] = 1
                i += 1
            until i = 5
            delocal int i = 5
            cur += 1
        fi queue[3] = cur - 1
        
        if queue[4] = cur then
            local int i = 0
            from i = 0 do
                if v4[i] = 1 && set[i] = 0 then
                    res4[i] += 1
                    set[i] += 1
                    queuecount += 1
                    queue[i] += queuecount
                fi res4[i] = 1
                i += 1
            until i = 5
            delocal int i = 5
            cur += 1
        fi queue[4] = cur - 1
        
    until cur = 6
    
    delocal int cur = 6
    delocal int queuecount = 5
    delocal int set[] = {1, 1, 1, 1, 1}

// procedure printPath(int res0[], int res1[], int res2[], int res3[], int res4[], int s, int v)
    
    // if s = v then
        // printf("Pathstep: %d", s)
    // else
        // if s = 0 then
            // local int i = 0
                // from i = 0 do
                    // if res0[i] = 1 then
                        // call printPath(res0, res1, res2, res3, res4, i, v)
                    // fi res0[i] = 1
                    // i += 1
                // until i = 5
            // delocal int i = 5
        // fi s = 0
        
        // if s = 1 then
            // local int i = 0
                // from i = 0 do
                    // if res1[i] = 1 then
                        // call printPath(res0, res1, res2, res3, res4, i, v)
                    // fi res1[i] = 1
                    // i += 1
                // until i = 5
            // delocal int i = 5
        // fi s = 1
        
        // if s = 2 then
            // local int i = 0
                // from i = 0 do
                    // if res2[i] = 1 then
                        // call printPath(res0, res1, res2, res3, res4, i, v)
                    // fi res2[i] = 1
                    // i += 1
                // until i = 5
            // delocal int i = 5
        // fi s = 2
        
        // if s = 3 then
            // local int i = 0
                // from i = 0 do
                    // if res3[i] = 1 then
                        // call printPath(res0, res1, res2, res3, res4, i, v)
                    // fi res3[i] = 1
                    // i += 1
                // until i = 5
            // delocal int i = 5
        // fi s = 3
        
        // if s = 4 then
            // local int i = 0
                // from i = 0 do
                    // if res4[i] = 1 then
                        // call printPath(res0, res1, res2, res3, res4, i, v)
                    // fi res4[i] = 1
                    // i += 1
                // until i = 5
            // delocal int i = 5
        // else
            // error("No path found")
        // fi s = 4
    // fi s = v
    
    
procedure main()
    
    int queue[] = {1, 0, 0, 0, 0}
    int queue2[] = {1, 0, 0, 0, 0}
    
    int resa[5]
    int resb[5]
    int resc[5]
    int resd[5]
    int rese[5]
    
    int resa_[5]
    int resb_[5]
    int resc_[5]
    int resd_[5]
    int rese_[5]
    
    int a[] = {0, 1, 0, 0, 1}
    int b[] = {1, 0, 1, 1, 0}
    int c[] = {0, 1, 0, 0, 0}
    int d[] = {0, 1, 0, 0, 1}
    int e[] = {1, 0, 0, 1, 0}
    
    print("Start. \n")
    print("Initial graph as a adjacency matrix:")
    show(a)
    show(b)
    show(c)
    show(d)
    show(e)
    
    call BFS(a, b, c, d, e, resa, resb, resc, resd, rese, queue)
    print("\nBreadth-first tree with a as root:")
    show(resa)
    show(resb)
    show(resc)
    show(resd)
    show(rese)
    print("\n")
    
    call BFS(c, b, a, d, e, resc_, resb_, resa_, resd_, rese_, queue2)
    print("\nBreadth-first tree with c as root:")
    show(resc_)
    show(resb_)
    show(resa_)
    show(resd_)
    show(rese_)
    print("\n")
//    call printPath(resa, resb, resc, resd, rese, 0, 3)
