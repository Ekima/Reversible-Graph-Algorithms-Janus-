/*
 * Kruskal's Algorithm
 * Takes a weighted, undirected graph G and returns a set A containing a
 * forest representing a single minimum spanning tree.
 * G is represented as an adjacency matrix of size n x n, where n is the amount
 * of nodes in G, as well as a variable edgecount containing the amount of
 * edges in the graph.
 * A is represented like a weighted, directed graph in an adjacency matrix and
 * must be of size n x n.
 */

/****************** START QUICKSORT *******************/
/* Created by Holger Bock Axelsen and Tetsuo Yokoyama */
/****************** START QUICKSORT *******************/

// in-place quick sort
procedure partition2(int a[], int l, int r, int p, int ord[])
  local int j = l
    from  j = l
    loop  if a[0][j] <= a[0][r] then
            p += 1
            local int k = p  // slide a[p..j-1] to the right by one, and move a[j] to position p
              from  k = p
              loop  a[0][k] <=> a[0][j]
                    a[1][k] <=> a[1][j]
                    a[2][k] <=> a[2][j]
                    ord[k] <=> ord[j]
                    k += 1
              until k = j
            delocal int k = j  
          fi (p >= l) && (ord[p] >= ord[j])
          j += 1
    until j = r + 1
  delocal int j = r + 1

// xor-copy to p the index of the maximum of ord[l..r]
procedure max(int p, int ord[], int l, int r)
  local stack gb = nil
    local int m = 0
      call max_sub(m,ord,l,r,gb)
      p ^= m
      uncall max_sub(m,ord,l,r,gb)
    delocal int m = 0
  delocal stack gb = nil

procedure max_sub(int m, int ord[], int l, int r, stack gb)
  m ^= l
  local int i = l + 1
    from  i = l + 1
    loop  if ord[i] >= ord[m] then
            push(m,gb)
            m ^= i
            push(1,gb)
          else
            push(0,gb)
          fi top(gb) = 1
          i += 1
    until i = r + 1
  delocal int i = r + 1

procedure qsort2(int a[], int l, int r, int p[])
  if l < r then
    local int q = l - 1     // q remembers where to divide
      call partition2(a,l,r,q,p)
      call qsort2(a,l,q-1,p)
      call qsort2(a,q+1,r,p)
      call max(q,p,l,r)     // zero clear q
    delocal int q = 0
  fi l < r

// Setting to p[] identity permutation of length n
procedure id_perm(int p[], int n)
  local int i = 0
    from  i = 0
    loop  p[i] ^= i
          i += 1
    until i = n
  delocal int i = n

/******************* END QUICKSORT ********************/
/* Created by Holger Bock Axelsen and Tetsuo Yokoyama */
/******************* END QUICKSORT ********************/  

/*
 * extractedges extract the edge information (starting node, ending node,
 * weight) of a graph G and returns it in a list.
 *
 * Parameters:
 * int array[]      An adjacency matrix.
 * int edgelist[]   An empty array of size |E|
 *
 * Returns:
 * A list of all edges in G.
 */
procedure extractedges(int G[], int edgelist[])
    local int i = 0, int j = 0, int s = 0
    
    from i = 0 do
        from j = i do
            if G[i][j] != 0 then
                edgelist[0][s] += G[i][j]
                edgelist[1][s] += i+1
                edgelist[2][s] += j+1
                s += 1
            fi G[i][j] != 0
            j += 1
        until j = size(G)
        i += 1
        j -= size(G) - i
    until i = size(G)
    
    delocal int i = size(G), int j = size(G), int s = size(G)

/*
 * findset recursively searches an adjacency matrix for a connection between a
 * node a and a node b.
 *
 * Parameters:
 * int a            First node of edge.
 * int b            Second node of edge.
 * int array[]      An adjacency matrix.
 * int visited[]    An empty array of size |V|
 * int visit        A counter value initialized to 0
 * int retval       The return value
 *
 * Returns:
 * A returnvalue retval, 1 if a and b are connected by edges and 0 if they are
 * not.
 */
procedure findset(int a, int b, int array[],
                  int visited[], int visit, int retval)
    // Visited and visit are used to keep track of which nodes have been visited
    // Once all nodes have been visited, we stop the recursion
    visited[a] += visit
    visit += 1
    
    if array[a][b] != 0  then
        retval += 1 // The element has been found, we return 1
    else
        local int i = 0
        from i = 0 do
            // Check for edges of current node a, call function recursively
            if array[a][i] != 0 && a != i && visited[i] = 0 && retval != 1 then
                call findset(i, b, array, visited, visit, retval)
            fi array[a][i] != 0 && a != i && visited[i] = visit
            i += 1
        until i = size(array)
        delocal int i = size(array)
    fi array[a][b] != 0
    visit -= 1

/*
 * addedge creates a weighted edge between two nodes, a and b, in a
 * two-dimensional array / adjacency matrix. array[a][b] should be empty before
 * adding the edge for a proper result. a and b should be within the range of
 * the array.
 *
 * Parameters:
 * int a            First node of edge.
 * int b            Second node of edge.
 * int weight       Weight of edge to be added.
 * int array[]      An adjacency matrix. 
 *
 * Returns:
 * An adjacency matrix with a new edge between a and b.
 */
procedure addedge(int a, int b, int weight, int array[])
    array[a][b] += weight
    if a != b then // Symmetric edge only added when not in the diagonal
        array[b][a] += weight
    fi a != b

/*
 * mstkruskal is the main algorithm, creating a minimum spanning tree from a
 * undirected, weighted graph.
 *
 * Parameters:
 * int G[]          An adjacency matrix representing G
 * int edgecount    The number of edges in the graph G
 * int A[]          An empty adjacency matrix for storing the result
 *
 * Returns:
 * An adjacency matrix containing a minimum spanning tree of G.
 */
procedure mstkruskal(int G[], int edgecount, int A[])    
    // Gather all of the edges into a list.
    local int edges[3][edgecount] = {{0}, {0}, {0}}
    call extractedges(G, edges)
    // Sort the list using quicksort
    local int p[edgecount] = {0}
    call id_perm(p, edgecount)
    call qsort2(edges, 0, edgecount - 1, p)
    
    local int i = 0, int ret = 0
    local int visit = 0 // Findset variable
    local int visited[size(G)] = {0} // Findset variable
    
    from i = 0 do // Go through all edges
        // Findset checks two nodes combined by an edge are in the same subset
        call findset(edges[1][i]-1, edges[2][i]-1, A, visited, visit, ret)
        if ret = 0 then
            // If they aren't, the second subset is added to the first
            uncall findset(edges[1][i]-1, edges[2][i]-1, A, visited, visit, ret)
            call addedge(edges[1][i]-1, edges[2][i]-1, edges[0][i], A)
        else
            // Or else, we nullify the findset variables
            uncall findset(edges[1][i]-1, edges[2][i]-1, A, visited, visit, ret)
        fi A[edges[1][i]-1][edges[2][i]-1] != 0
        i += 1
    until i = edgecount
    
    // Delocal values.
    delocal int visited[size(G)] = {0}
    delocal int visit = 0
    delocal int i = edgecount, int ret = 0
    
    uncall qsort2(edges, 0, edgecount - 1, p)
    uncall id_perm(p, edgecount)
    delocal int p[edgecount] = {0}
    uncall extractedges(G, edges)
    delocal int edges[3][edgecount] = {{0}, {0}, {0}}

procedure main()
    int G[][] = {{0, 2, 0, 5, 0},
               {2, 0, 0, 0, 4},
               {0, 0, 0, 4, 0},
               {5, 0, 4, 0, 7},
               {0, 4, 0, 7, 0}}
    int A[5][5] = {{0}, {0}, {0}, {0}, {0}}
    
    call mstkruskal(G, 5, A)