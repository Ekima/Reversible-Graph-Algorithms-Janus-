/*
 * Depth First Search
 * 
 * Takes an unweighted graph represented as an adjacency list.
 * Timestamp info is stored in a separate twodimensional array.
 * Returns the original graph with a list of timestamps represented the
 * trees in the graph.
 *
 * The adjacency list implementation is described in adjacencylist.janus
 */
 
 /*
 * getlist gets the contents of a single list in the adjacency list.
 *
 * Parameters:
 * int adjacent[]  A list of adjacency list elements
 * int start       A pointer to the start of the list to be extracted
 * int end         A pointer to the end of the list to be extracted
 * int res[]       A list to store the returned elements in
 * 
 * Returns:
 * A copy of a the items in a list in the adjacency list.
 */
 
procedure getlist(int adjacent[], int start, int end, int res[])
    // Elements of the wanted list are loaded into res
    local int r = start
    from r = start do
        res[r - start] += adjacent[r]
        r += 1
    until r = end
    delocal int r = end

/*
 * DFS initializes the depth first search of a graph G at time 0.
 *
 * Parameters:
 * int Gadjacent[] A list of adjacency list elements
 * int Gnodes[]    Information about the nodes (pointers and (empty) timestamps)
 * int Gsize       Number of nodes in G
 *
 * ** Note: Once a way to find the size of an array in a two-dimensional array
 * is created, Gsize can be replaced with a local int Gsize = Gnodes[0] **
 *
 * Returns:
 * The original graph represented by G and the pointers in Gnodes, with an
 * updated list of timestamps representing the subtrees of G
 */
procedure DFS(int Gadjacent[], int Gnodes[], int Gsize)
    local int time = 0
    local int i = 0
    
    // We run through each individual node and check if they have been visited
    // (timestamped). If they haven't we run DFSvisit.
    from i = 0 do
        if Gnodes[1][i] = 0 then
            call DFSvisit(Gadjacent, Gnodes, Gsize, i, time)
        fi Gnodes[2][i] = time
        i += 1
    until i = Gsize
    
    delocal int i = Gsize
    delocal int time = Gsize * 2

/*
 * DFSvisit marks the current node with the current time, then recursively
 * does the same with each of its adjacent nodes if they have not been visited.
 *
 * Parameters:
 * int Gadjacent[] A list of adjacency list elements
 * int Gnodes[]    Information about the nodes (pointers and (empty) timestamps)
 * int Gsize       Number of nodes in G
 * int u           A number indicating the current node visited
 * int time        The current time
 *
 * ** Note: Once a way to find the size of an array in a two-dimensional array
 * is created, Gsize can be replaced with a local int Gsize = Gnodes[0] **
 *
 * Returns:
 * A timestamped tree of all the subnotes in u
 */
procedure DFSvisit(int Gadjacent[], int Gnodes[], int Gsize, int u, int time)
    // The time is incremented and the node gets entry-timestamped
    time += 1
    Gnodes[1][u] += time
    
    // end contains a pointer to the end of the wanted list
    local int end = 0
    if u = Gsize - 1 then
        // If we try to get the last list we stop at the end of the element list
        end += size(Gadjacent)
    else
        // Or else, we stop where the next list starts
        end += Gnodes[0][u + 1]
    fi u = Gsize - 1
    
    // We get the adjacent nodes of current node
    local int curadj[end - Gnodes[0][u]] = {0}
    call getlist(Gadjacent, Gnodes[0][u], end, curadj)
    
    // The adjacent nodes are checked and if they have not been visited,
    // DFSvisit is called with the unvisited node
    local int r = 0
    from r = 0 do
        if Gnodes[1][curadj[r]-1] = 0 then
            call DFSvisit(Gadjacent, Gnodes, Gsize, curadj[r]-1, time)
        fi Gnodes[1][curadj[r]-1] = time || Gnodes[2][curadj[r]-1] = time
        r += 1
    until r = size(curadj)
    delocal int r = size(curadj)
    
    // The time is incremented and the node gets exit-timestamped
    time += 1
    Gnodes[2][u] += time
    
    uncall getlist(Gadjacent, Gnodes[0][u], end, curadj)
    delocal int curadj[end - Gnodes[0][u]] = {0}
    
    // end is delocated
    if u = Gsize - 1 then
        end -= size(Gadjacent)
    else
        end -= Gnodes[0][u + 1]
    fi u = Gsize - 1
    delocal int end = 0

/*
 * Main procedure. Creates an adjacency list and runs DFS on it.
 */
procedure main()
    // Adjacency list, list of adjacent nodes
    int Gadjacent[] = {2, 4, 1, 5, 4, 1, 3, 5, 2, 4}
    // Adjacency list, node information.
    // Each node has a pointer to their first element and two timestamps
    int Gnodes[3][5] = {{0, 2, 4, 5, 8},{0},{0}}
    // Number of nodes in G
    int Gsize = 5
    
    call DFS(Gadjacent, Gnodes, Gsize)
